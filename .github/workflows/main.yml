# .github/workflows/main.yml
name: LaTeX CI (pure TeX Live, minimal, cached, on-demand)

on:
  push:
    branches:
      - release

permissions:
  contents: write

env:
  ENTRY_TEX: main.tex
  ENGINE: pdflatex
  TL_ROOT: ${{ github.workspace }}/.tl # install TeX Live here (repo-local, cacheable)
  # Mirror for installation and tlmgr updates
  TL_MIRROR: https://mirror.ctan.org/systems/texlive/tlnet

concurrency:
  group: latex-ci-${{ github.ref }}
  cancel-in-progress: false

jobs:
  build_and_release:
    name: Build and Release PDF
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      # Step 1: Check out the repository's code so the workflow can access it
      - name: Check out repository
        uses: actions/checkout@v5.0.0
        with:
          fetch-depth: 0

      # Cache the TeX Live install + user trees so installed packages persist
      - name: Restore TeX Live cache
        uses: actions/cache@v4.2.4
        with:
          path: |
            ${{ env.TL_ROOT }}
            ${{ runner.temp }}/texlive-installer
            ~/.texlive*
            ~/texmf
          key: texlive-${{ runner.os }}-sources-${{ hashFiles('**/*.tex', '**/*.sty', '**/*.cls', '**/*.bib') }}
          restore-keys: |
            texlive-${{ runner.os }}-sources-

      - name: Install TeX Live (scheme-basic) if missing
        shell: bash
        run: |
          set -euxo pipefail

          # Determine bin dir (if already installed)
          if [ -d "${TL_ROOT}/bin" ] && [ -n "$(ls -A "${TL_ROOT}/bin" 2>/dev/null || true)" ]; then
            TL_BIN_DIR=$(find "${TL_ROOT}/bin" -mindepth 1 -maxdepth 1 -type d | head -n1)
          else
            TL_BIN_DIR=""
          fi

          if [ -x "${TL_BIN_DIR}/tlmgr" ]; then
            echo "TeX Live already installed at ${TL_ROOT}"
          else
            echo "Installing TeX Live to ${TL_ROOT}"
            mkdir -p "${RUNNER_TEMP}/texlive-installer"
            cd "${RUNNER_TEMP}/texlive-installer"
            curl -fsSL ${TL_MIRROR}/install-tl-unx.tar.gz | tar -xz --strip-components=1

            # Non-interactive install profile
            cat > /tmp/texlive.profile <<'PROFILE'
          selected_scheme scheme-basic
          TEXDIR __TL_ROOT__
          TEXMFCONFIG $HOME/.texlive/texmf-config
          TEXMFVAR $HOME/.texlive/texmf-var
          TEXMFHOME $HOME/texmf
          TEXMFLOCAL __TL_ROOT__/texmf-local
          TEXMFSYSCONFIG __TL_ROOT__/texmf-config
          TEXMFSYSVAR __TL_ROOT__/texmf-var
          binary_x86_64-linux 1
          instopt_adjustrepo 1
          instopt_write18_restricted 1
          tlpdbopt_autobackup 0
          tlpdbopt_desktop_integration 0
          tlpdbopt_file_assocs 0
          tlpdbopt_install_docfiles 0
          tlpdbopt_install_srcfiles 0
          tlpdbopt_w32_multi_user 0
          PROFILE

            # Inject TL_ROOT into profile
            sed -i "s#__TL_ROOT__#${TL_ROOT}#g" /tmp/texlive.profile

            # Run the installer
            ./install-tl -profile /tmp/texlive.profile

            # Discover bin dir after installation
            TL_BIN_DIR=$(find "${TL_ROOT}/bin" -mindepth 1 -maxdepth 1 -type d | head -n1)
          fi

          # Add TeX Live to PATH for this job
          echo "${TL_BIN_DIR}" >> "$GITHUB_PATH"

      # - name: Upload TeX Live profile(s)
      #   if: always()
      #   uses: actions/upload-artifact@v4
      #   with:
      #     name: texlive-profile-${{ runner.os }}-${{ github.run_id }}
      #     path: |
      #       /tmp/texlive.profile
      #       /tmp/texlive.profile.resolved
      #     if-no-files-found: warn
      #     retention-days: 7

      - name: Bootstrap tlmgr and minimal tools
        shell: bash
        run: |
          set -euxo pipefail
          tlmgr option repository "${TL_MIRROR}"
          tlmgr update --self --all
          # Build helpers
          tlmgr install latexmk texliveonfly

      # External tool discipline: detect needs before compile
      - name: Detect external tool needs
        id: detect
        shell: bash
        run: |
          set -euo pipefail
          NEED_BIBER="false"
          NEED_GLOSS="false"
          NEED_MINTED="false"
          NEED_TIKZEXT="false"

          # Search only relevant tree to reduce noise
          SRC_DIR="."
          grep -R -nE '\\usepackage(\[[^]]*\])?{biblatex}' "$SRC_DIR" >/dev/null 2>&1 && NEED_BIBER="true"
          grep -R -nE '\\usepackage(\[[^]]*\])?{glossaries(-extra)?}|\\makeglossaries|\\printglossary' "$SRC_DIR" >/dev/null 2>&1 && NEED_GLOSS="true"
          grep -R -nE '\\usepackage(\[[^]]*\])?{minted}' "$SRC_DIR" >/dev/null 2>&1 && NEED_MINTED="true"
          grep -R -nE '\\tikzexternalize|\\usetikzlibrary\{[^}]*external[^}]*\}' "$SRC_DIR" >/dev/null 2>&1 && NEED_TIKZEXT="true"

          echo "NEED_BIBER=$NEED_BIBER"       >> "$GITHUB_OUTPUT"
          echo "NEED_GLOSS=$NEED_GLOSS"       >> "$GITHUB_OUTPUT"
          echo "NEED_MINTED=$NEED_MINTED"     >> "$GITHUB_OUTPUT"
          echo "NEED_TIKZEXT=$NEED_TIKZEXT"   >> "$GITHUB_OUTPUT"

      - name: Install external tools as needed
        if: steps.detect.outputs.NEED_BIBER == 'true' || steps.detect.outputs.NEED_GLOSS == 'true' || steps.detect.outputs.NEED_MINTED == 'true'
        shell: bash
        run: |
          set -euxo pipefail
          if [ "${{ steps.detect.outputs.NEED_BIBER }}" = "true" ]; then
            tlmgr install biber biblatex
          fi
          if [ "${{ steps.detect.outputs.NEED_GLOSS }}" = "true" ]; then
            tlmgr install glossaries xindy makeindex || tlmgr install glossaries xindy
          fi
          if [ "${{ steps.detect.outputs.NEED_MINTED }}" = "true" ]; then
            tlmgr install minted
            python3 -m pip install --user --upgrade pip Pygments
            echo "$HOME/.local/bin" >> "$GITHUB_PATH"
          fi

      - name: Build PDF (on-demand packages)
        shell: bash
        run: |
          set -euxo pipefail

          case "${ENGINE}" in
            pdflatex) LMK_FLAG="-pdf" ;;
            xelatex)  LMK_FLAG="-pdfxe" ;;
            lualatex) LMK_FLAG="-pdflua" ;;
            *) echo "Unknown ENGINE=${ENGINE}"; exit 1 ;;
          esac


          # Default to no shell-escape; enable only for minted or tikz externalization
          SHELL_ESCAPE=""
          if [ "${{ steps.detect.outputs.NEED_MINTED }}" = "true" ] || [ "${{ steps.detect.outputs.NEED_TIKZEXT }}" = "true" ]; then
            SHELL_ESCAPE="-shell-escape"
          fi

          # texliveonfly installs missing packages via tlmgr during the build
          latexmk ${LMK_FLAG} -f\
            -interaction=nonstopmode -file-line-error ${SHELL_ESCAPE}\
            -pdflatex='texliveonfly -c ${ENGINE} -a "%O" %S'\
            "$ENTRY_TEX"

          OUT_PDF="${ENTRY_TEX%.tex}.pdf"
          test -f "$OUT_PDF" || (echo "Output PDF not found: $OUT_PDF" && exit 2)
          echo "OUT_PDF=${OUT_PDF}" >> "$GITHUB_ENV"

      - name: Record installed TeX packages (optional, for reproducibility)
        shell: bash
        run: |
          set -euxo pipefail
          tlmgr info --only-installed --data name | sort > texlive.packages.txt || true
          wc -l texlive.packages.txt || true

      - name: Compute release metadata (title and tag)
        id: meta
        shell: bash
        run: |
          TITLE="$(git log -1 --pretty=%s)"   # first line only
          echo "title=$TITLE" >> "$GITHUB_OUTPUT"
          TAG="rel-$(date -u +'%Y%m%d-%H%M%S')-${GITHUB_SHA::7}"
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"

      - name: Rename PDFs with tag
        env:
          TAG_NAME: ${{ steps.meta.outputs.tag }}
        run: |
          set -euxo pipefail
          mkdir -p dist
          shopt -s nullglob
          for f in ./*.pdf; do
            bn="$(basename "$f")"
            base="${bn%.pdf}"
            cp "$f" "dist/${base}-${TAG_NAME}.pdf"
          done

          # Expose for the next step
          echo "RELEASE_FILES=dist/*.pdf" >> "$GITHUB_ENV"

      - name: Create GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG_NAME: ${{ steps.meta.outputs.tag }}
          RELEASE_NAME: ${{ steps.meta.outputs.title }}
        run: |
          gh release create "$TAG_NAME" \
          --title "$RELEASE_NAME" \
          --target "$GITHUB_SHA" \
          --generate-notes \
          --latest \
          ${{ env.RELEASE_FILES }}

      - name: Push PDF to preview branch
        env:
          TAG_NAME: ${{ steps.meta.outputs.tag }}
          RELEASE_NAME: ${{ steps.meta.outputs.title }}
        run: |
          branch="releases"
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          if git ls-remote --exit-code --heads origin "$branch"; then
            git fetch origin "$branch":"$branch"
            git switch "$branch"
          else
            git checkout --orphan "$branch"
            git rm -rf .
            find . -maxdepth 1 -type f -delete
          fi

          cp ${{ env.RELEASE_FILES }} ./
          git add *.pdf
          git commit -m "$TAG_NAME: $RELEASE_NAME"
          git push origin HEAD:"$branch"
