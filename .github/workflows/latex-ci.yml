# .github/workflows/latex-ci.yml
name: LaTeX CI (TeX Live, cached, on-demand packages)

on:
  workflow_call:
    inputs:
      # LaTeX document configuration
      entry_tex:
        description: 'Main LaTeX file to compile (e.g., main.tex)'
        required: false
        type: string
        default: 'main.tex'

      engine:
        description: 'LaTeX engine to use (pdflatex, xelatex, lualatex)'
        required: false
        type: string
        default: 'pdflatex'

      # Build configuration
      working_directory:
        description: 'Working directory containing LaTeX files'
        required: false
        type: string
        default: '.'

      texlive_scheme:
        description: 'TeX Live scheme to install (basic, minimal, full)'
        required: false
        type: string
        default: 'basic'

      # Release configuration
      create_release:
        description: 'Whether to create a GitHub release'
        required: false
        type: boolean
        default: true

      release_tag_prefix:
        description: 'Prefix for release tags'
        required: false
        type: string
        default: 'rel'

      push_to_releases_branch:
        description: 'Whether to push PDFs to releases branch'
        required: false
        type: boolean
        default: true

      releases_branch_name:
        description: 'Name of the releases branch'
        required: false
        type: string
        default: 'releases'

      # Advanced configuration
      texlive_mirror:
        description: 'TeX Live mirror URL'
        required: false
        type: string
        default: 'https://mirror.ctan.org/systems/texlive/tlnet'

      timeout_minutes:
        description: 'Job timeout in minutes'
        required: false
        type: number
        default: 30

      cache_key_suffix:
        description: 'Additional suffix for cache key'
        required: false
        type: string
        default: ''

      # Output configuration
      artifact_name:
        description: 'Name for PDF artifacts'
        required: false
        type: string
        default: 'latex-pdfs'

      keep_build_deps:
        description: 'Whether to upload build deps for debugging'
        required: false
        type: boolean
        default: false

      keep_build_artifacts:
        description: 'Whether to upload build artifacts for debugging'
        required: false
        type: boolean
        default: false

    outputs:
      pdf_files:
        description: 'Generated PDF files'
        value: ${{ jobs.build_latex.outputs.pdf_files }}

      release_tag:
        description: 'Created release tag'
        value: ${{ jobs.build_latex.outputs.release_tag }}

      release_url:
        description: 'URL of created release'
        value: ${{ jobs.build_latex.outputs.release_url }}

permissions:
  contents: write

env:
  ENTRY_TEX: ${{ inputs.entry_tex }}
  ENGINE: ${{ inputs.engine }}
  TL_ROOT: ${{ github.workspace }}/.tl
  TL_MIRROR: ${{ inputs.texlive_mirror }}
  WORKING_DIR: ${{ inputs.working_directory }}

concurrency:
  group: latex-ci-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  build_latex:
    name: Build LaTeX Documents
    runs-on: ubuntu-latest
    timeout-minutes: ${{ inputs.timeout_minutes }}

    outputs:
      pdf_files: ${{ steps.build.outputs.pdf_files }}
      release_tag: ${{ steps.meta.outputs.tag }}
      release_url: ${{ steps.release.outputs.url }}

    steps:
      # Step 1: Check out the repository's code
      - name: Check out repository
        uses: actions/checkout@v5.0.0
        with:
          fetch-depth: 0

      # Cache the TeX Live install + user trees
      - name: Restore TeX Live cache
        uses: actions/cache@v4.2.4
        with:
          path: |
            ${{ env.TL_ROOT }}
            ${{ runner.temp }}/texlive-installer
            ~/.texlive*
            ~/texmf
          key: texlive-${{ runner.os }}-${{ inputs.texlive_scheme }}-${{ hashFiles(format('{0}/**/*.tex', inputs.working_directory), format('{0}/**/*.sty', inputs.working_directory), format('{0}/**/*.cls', inputs.working_directory), format('{0}/**/*.bib', inputs.working_directory)) }}${{ inputs.cache_key_suffix }}
          restore-keys: |
            texlive-${{ runner.os }}-${{ inputs.texlive_scheme }}-
            texlive-${{ runner.os }}-

      - name: Install TeX Live if missing
        shell: bash
        run: |
          set -euxo pipefail

          # Determine bin dir (if already installed)
          if [ -d "${TL_ROOT}/bin" ] && [ -n "$(ls -A "${TL_ROOT}/bin" 2>/dev/null || true)" ]; then
            TL_BIN_DIR=$(find "${TL_ROOT}/bin" -mindepth 1 -maxdepth 1 -type d | head -n1)
          else
            TL_BIN_DIR=""
          fi

          if [ -x "${TL_BIN_DIR}/tlmgr" ]; then
            echo "TeX Live already installed at ${TL_ROOT}"
          else
            echo "Installing TeX Live to ${TL_ROOT}"
            mkdir -p "${RUNNER_TEMP}/texlive-installer"
            cd "${RUNNER_TEMP}/texlive-installer"
            curl -fsSL ${TL_MIRROR}/install-tl-unx.tar.gz | tar -xz --strip-components=1

            # Determine scheme based on input
            SCHEME="scheme-${{ inputs.texlive_scheme }}"

            # Non-interactive install profile
            cat > /tmp/texlive.profile <<PROFILE
          selected_scheme ${SCHEME}
          TEXDIR ${TL_ROOT}
          TEXMFCONFIG \$HOME/.texlive/texmf-config
          TEXMFVAR \$HOME/.texlive/texmf-var
          TEXMFHOME \$HOME/texmf
          TEXMFLOCAL ${TL_ROOT}/texmf-local
          TEXMFSYSCONFIG ${TL_ROOT}/texmf-config
          TEXMFSYSVAR ${TL_ROOT}/texmf-var
          binary_x86_64-linux 1
          instopt_adjustrepo 0
          instopt_write18_restricted 1
          tlpdbopt_autobackup 0
          tlpdbopt_desktop_integration 0
          tlpdbopt_file_assocs 0
          tlpdbopt_install_docfiles 0
          tlpdbopt_install_srcfiles 0
          tlpdbopt_w32_multi_user 0
          PROFILE

            # Run the installer
            ./install-tl -profile /tmp/texlive.profile

            # Discover bin dir after installation
            TL_BIN_DIR=$(find "${TL_ROOT}/bin" -mindepth 1 -maxdepth 1 -type d | head -n1)
          fi

          # Add TeX Live to PATH for this job
          echo "${TL_BIN_DIR}" >> "$GITHUB_PATH"

      - name: Upload TeX Live profile(s)
        if: always()
        uses: actions/upload-artifact@v4.6.2
        with:
          name: texlive-profile-${{ runner.os }}-${{ github.run_id }}
          path: |
            /tmp/texlive.profile
            /tmp/texlive.profile.resolved
          if-no-files-found: warn
          retention-days: 7

      - name: Bootstrap tlmgr and minimal tools
        shell: bash
        run: |
          set -euxo pipefail
          tlmgr option repository "${TL_MIRROR}"
          tlmgr update --self --all || true
          # Build helpers
          tlmgr install latexmk texliveonfly

      # External tool discipline: detect needs before compile
      - name: Detect external tool needs
        id: detect
        shell: bash
        working-directory: ${{ inputs.working_directory }}
        run: |
          set -euo pipefail
          NEED_BIBER="false"
          NEED_GLOSS="false"
          NEED_MINTED="false"
          NEED_TIKZEXT="false"

          # Search only relevant tree to reduce noise
          SRC_DIR="."
          grep -R -nE '\\usepackage(\[[^]]*\])?{biblatex}' "$SRC_DIR" >/dev/null 2>&1 && NEED_BIBER="true" || true
          grep -R -nE '\\usepackage(\[[^]]*\])?{glossaries(-extra)?}|\\makeglossaries|\\printglossary' "$SRC_DIR" >/dev/null 2>&1 && NEED_GLOSS="true" || true
          grep -R -nE '\\usepackage(\[[^]]*\])?{minted}' "$SRC_DIR" >/dev/null 2>&1 && NEED_MINTED="true" || true
          grep -R -nE '\\tikzexternalize|\\usetikzlibrary\{[^}]*external[^}]*\}' "$SRC_DIR" >/dev/null 2>&1 && NEED_TIKZEXT="true" || true

          echo "NEED_BIBER=$NEED_BIBER"       >> "$GITHUB_OUTPUT"
          echo "NEED_GLOSS=$NEED_GLOSS"       >> "$GITHUB_OUTPUT"
          echo "NEED_MINTED=$NEED_MINTED"     >> "$GITHUB_OUTPUT"
          echo "NEED_TIKZEXT=$NEED_TIKZEXT"   >> "$GITHUB_OUTPUT"

      - name: Install external tools as needed
        if: steps.detect.outputs.NEED_BIBER == 'true' || steps.detect.outputs.NEED_GLOSS == 'true' || steps.detect.outputs.NEED_MINTED == 'true'
        shell: bash
        run: |
          set -euxo pipefail
          if [ "${{ steps.detect.outputs.NEED_BIBER }}" = "true" ]; then
            tlmgr install biber biblatex
          fi
          if [ "${{ steps.detect.outputs.NEED_GLOSS }}" = "true" ]; then
            tlmgr install glossaries xindy makeindex || tlmgr install glossaries xindy
          fi
          if [ "${{ steps.detect.outputs.NEED_MINTED }}" = "true" ]; then
            tlmgr install minted
            python3 -m pip install --user --upgrade pip Pygments
            echo "$HOME/.local/bin" >> "$GITHUB_PATH"
          fi

      - name: Build PDF (on-demand packages)
        id: build
        shell: bash
        working-directory: ${{ inputs.working_directory }}
        run: |
          set -euxo pipefail

          case "${ENGINE}" in
            pdflatex) LMK_FLAG="-pdf" ;;
            xelatex)  LMK_FLAG="-pdfxe" ;;
            lualatex) LMK_FLAG="-pdflua" ;;
            *) echo "Unknown ENGINE=${ENGINE}"; exit 1 ;;
          esac

          # Default to no shell-escape; enable only for minted or tikz externalization
          SHELL_ESCAPE=""
          if [ "${{ steps.detect.outputs.NEED_MINTED }}" = "true" ] || [ "${{ steps.detect.outputs.NEED_TIKZEXT }}" = "true" ]; then
            SHELL_ESCAPE="-shell-escape"
          fi

          # texliveonfly installs missing packages via tlmgr during the build
          latexmk ${LMK_FLAG} -f \
            -interaction=nonstopmode -file-line-error ${SHELL_ESCAPE} \
            -pdflatex='texliveonfly -c ${ENGINE} -a "%O" %S' \
            "$ENTRY_TEX"

          OUT_PDF="${ENTRY_TEX%.tex}.pdf"
          test -f "$OUT_PDF" || (echo "Output PDF not found: $OUT_PDF" && exit 2)

          # Set outputs
          echo "OUT_PDF=${OUT_PDF}" >> "$GITHUB_ENV"

          # Find all generated PDFs
          PDF_FILES=$(find . -name "*.pdf" -type f | tr '\n' ' ')
          echo "pdf_files=${PDF_FILES}" >> "$GITHUB_OUTPUT"

      - name: Record installed TeX packages (for reproducibility)
        if: inputs.keep_build_deps
        shell: bash
        run: |
          set -euxo pipefail
          tlmgr info --only-installed --data name | sort > texlive.packages.txt || true
          wc -l texlive.packages.txt || true

      - name: Upload build deps
        if: inputs.keep_build_deps
        uses: actions/upload-artifact@v4.6.2
        with:
          name: ${{ inputs.artifact_name }}-build-deps
          path: |
            texlive.packages.txt
          if-no-files-found: ignore
          retention-days: 7

      - name: Upload build artifacts
        if: inputs.keep_build_artifacts
        uses: actions/upload-artifact@v4.6.2
        with:
          name: ${{ inputs.artifact_name }}-build-artifacts
          path: |
            ${{ inputs.working_directory }}/*.log
            ${{ inputs.working_directory }}/*.aux
            ${{ inputs.working_directory }}/*.fls
            ${{ inputs.working_directory }}/*.fdb_latexmk
          if-no-files-found: ignore
          retention-days: 7

      - name: Compute release metadata (title and tag)
        if: inputs.create_release
        id: meta
        shell: bash
        run: |
          TITLE="$(git log -1 --pretty=%s)"   # first line only
          echo "title=$TITLE" >> "$GITHUB_OUTPUT"
          TAG="${{ inputs.release_tag_prefix }}-$(date -u +'%Y%m%d-%H%M%S')-${GITHUB_SHA::7}"
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"

      - name: Prepare release artifacts
        if: inputs.create_release
        env:
          TAG_NAME: ${{ steps.meta.outputs.tag }}
        working-directory: ${{ inputs.working_directory }}
        run: |
          set -euxo pipefail
          mkdir -p dist
          shopt -s nullglob
          for f in ./*.pdf; do
            if [ -f "$f" ]; then
              bn="$(basename "$f")"
              base="${bn%.pdf}"
              cp "$f" "./dist/${base}-${TAG_NAME}.pdf"
            fi
          done

          # Count and list files
          cd ./dist
          if ls *.pdf 1> /dev/null 2>&1; then
            echo "RELEASE_FILES=$(ls *.pdf | tr '\n' ' ')" >> "$GITHUB_ENV"
            echo "Generated release files:"
            ls -la *.pdf
          else
            echo "No PDF files found for release"
            echo "RELEASE_FILES=" >> "$GITHUB_ENV"
          fi

      - name: Upload PDF artifacts
        uses: actions/upload-artifact@v4.6.2
        with:
          name: ${{ inputs.artifact_name }}
          path: ${{ inputs.working_directory }}/*.pdf
          if-no-files-found: warn
          retention-days: 30

      - name: Create GitHub Release
        if: inputs.create_release && env.RELEASE_FILES != ''
        id: release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG_NAME: ${{ steps.meta.outputs.tag }}
          RELEASE_NAME: ${{ steps.meta.outputs.title }}
        run: |
          cd dist
          RELEASE_URL=$(gh release create "$TAG_NAME" \
            --title "$RELEASE_NAME" \
            --target "$GITHUB_SHA" \
            --generate-notes \
            --latest \
            *.pdf | tail -n1)
          echo "url=$RELEASE_URL" >> "$GITHUB_OUTPUT"

      - name: Push PDF to releases branch
        if: inputs.push_to_releases_branch && env.RELEASE_FILES != ''
        env:
          TAG_NAME: ${{ steps.meta.outputs.tag }}
          RELEASE_NAME: ${{ steps.meta.outputs.title }}
          BRANCH_NAME: ${{ inputs.releases_branch_name }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          if git ls-remote --exit-code --heads origin "$BRANCH_NAME"; then
            git fetch origin "$BRANCH_NAME":"$BRANCH_NAME"
            git switch "$BRANCH_NAME"
          else
            git checkout --orphan "$BRANCH_NAME"
            git rm -rf . 2>/dev/null || true
            find . -maxdepth 1 -type f -delete 2>/dev/null || true
          fi

          cp dist/*.pdf ./ 2>/dev/null || true
          if ls *.pdf 1> /dev/null 2>&1; then
            git add *.pdf
            git commit -m "$TAG_NAME: $RELEASE_NAME"
            git push origin HEAD:"$BRANCH_NAME"
          else
            echo "No PDF files to push to releases branch"
          fi
